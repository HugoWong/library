(window.webpackJsonp=window.webpackJsonp||[]).push([[103],{423:function(a,s,e){"use strict";e.r(s);var t=e(3),r=Object(t.a)({},(function(){var a=this,s=a._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h2",{attrs:{id:"_1-rdb"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-rdb"}},[a._v("#")]),a._v(" 1.RDB")]),a._v(" "),s("p",[a._v("RDB（Redis DataBase）是 Redis 中默认的持久化机制，将内存中的数据以快照的方式异步保存到磁盘指定目录的"),s("code",[a._v(".rdb")]),a._v("文件中，可以通过配置文件中"),s("code",[a._v("save")]),a._v("参数来定义快照的周期")]),a._v(" "),s("h3",{attrs:{id:"流程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#流程"}},[a._v("#")]),a._v(" 流程")]),a._v(" "),s("h4",{attrs:{id:"save"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#save"}},[a._v("#")]),a._v(" save")]),a._v(" "),s("p",[a._v("指令执行完成前不执行其他操作，仅用于迁移、维护等数据备份，生产环境谨慎使用")]),a._v(" "),s("h4",{attrs:{id:"bgsave"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#bgsave"}},[a._v("#")]),a._v(" bgsave")]),a._v(" "),s("p",[a._v("指令执行时，Redis 会调用 glibc 的函数 fork 出一个子进程，先将数据写到磁盘上的一个临时 .rdb 文件中，写入完成后再将原来的 .rdb 文件替换掉\n而 "),s("code",[a._v("COW 机制")]),a._v("（copy-on-write）就是保证上述步骤的前提：当主进程执行读操作的时候是访问共享内存的，而主进程执行写操作的时候，则会拷贝一份数据，执行写操作；以此减少分配和复制时带来的瞬时延迟以及不必要的资源分配")]),a._v(" "),s("h3",{attrs:{id:"优点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#优点"}},[a._v("#")]),a._v(" 优点")]),a._v(" "),s("ul",[s("li",[a._v("只有一个文件 dump.rdb ，按时间点保存数据集，便于备份和恢复")]),a._v(" "),s("li",[a._v("持久化时主进程可以继续处理其他命令，不进行任何 I/O 操作，保证 Redis 的高性能")]),a._v(" "),s("li",[a._v("RDB 是一个紧凑压缩的二进制文件，重载效率比 AOF 持久化更高，在数据量大时更明显")])]),a._v(" "),s("h3",{attrs:{id:"缺点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#缺点"}},[a._v("#")]),a._v(" 缺点")]),a._v(" "),s("ul",[s("li",[a._v("可能出现数据丢失，在两次 RDB 持久化的时间间隔中，如果出现宕机，则会丢失这段时间中的数据")]),a._v(" "),s("li",[a._v("由于 RDB 是通过 fork 子进程来协助完成数据持久化，当数据集较大时，可能会导致间歇性暂停服务")])]),a._v(" "),s("h2",{attrs:{id:"_2-aof"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-aof"}},[a._v("#")]),a._v(" 2.AOF")]),a._v(" "),s("p",[a._v("AOF ，及追加文件（Append Only File），当 Redis 处理每一个写命令都会记录在 AOF 文件中，可以看做是命令日志文件")]),a._v(" "),s("h3",{attrs:{id:"流程-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#流程-2"}},[a._v("#")]),a._v(" 流程")]),a._v(" "),s("p",[a._v("需要设置 AOF 的同步选项，因为对文件进行写入并不会马上将内容同步到磁盘上，而是先存储到缓冲区中，同步选项有三种配置项选择：")]),a._v(" "),s("div",{staticClass:"language-bash line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("#是否开启，默认 no，开启换为 yes")]),a._v("\nappendonly "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("yes")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("#同步选项")]),a._v("\nappendfsync everysec\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br")])]),s("ul",[s("li",[a._v("always：同步记录，可靠性高，I/O 开销大，影响性能较大")]),a._v(" "),s("li",[a._v("everysec：每秒同步一次，性能适中，最多丢失 1 秒的数据")]),a._v(" "),s("li",[a._v("no：默认配置，即不使用 AOF 持久化，性能最好，可靠性最差")])]),a._v(" "),s("p",[a._v("随着 Redis 的运行，AOF 的日志会越来越长，如果实例宕机重启，重载整个 AOF 将会变得十分耗时；为了解决这个问题，Redis 提供 "),s("code",[a._v("bgrewriteaof")]),a._v(" 指令，可以将 AOF 文件进行压缩，也可以选择自动触发，在配置文件中配置")]),a._v(" "),s("div",{staticClass:"language-bash line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[a._v("no-appendfsync-on-rewrite "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("yes")]),a._v("\nauto-aof-rewrite-precentage "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("100")]),a._v("\nauto-aof-rewrite-min-zise 64mb\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br")])]),s("h3",{attrs:{id:"优点-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#优点-2"}},[a._v("#")]),a._v(" 优点")]),a._v(" "),s("p",[a._v("实现持久化，数据安全，AOF持久化可以配置 appendfsync 属性为 always，每进行一次命令操作就记录到AOF文件中一次，数据最多丢失一次\n通过 append 模式写文件，即使中途服务器宕机，可以通过 Redis-check-aof 工具解决数据一致性问题\nAOF 机制的 rewrite 模式。AOF 文件的文件大小触碰到临界点时，rewrite 模式会被运行，重写内存中的所有数据，从而缩小文件体积")]),a._v(" "),s("h3",{attrs:{id:"缺点-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#缺点-2"}},[a._v("#")]),a._v(" 缺点")]),a._v(" "),s("ul",[s("li",[a._v("AOF 文件大，比 RDB 文件大很多")]),a._v(" "),s("li",[a._v("比 RDB 持久化启动效率低，数据集大时较为明显")]),a._v(" "),s("li",[a._v("AOF 文件体积可能迅速变大，需要定期执行重写操作来降低文件体积")])]),a._v(" "),s("h2",{attrs:{id:"混合"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#混合"}},[a._v("#")]),a._v(" 混合")]),a._v(" "),s("p",[a._v("顾名思义，")])])}),[],!1,null,null,null);s.default=r.exports}}]);