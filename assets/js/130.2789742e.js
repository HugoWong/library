(window.webpackJsonp=window.webpackJsonp||[]).push([[130],{443:function(t,a,s){"use strict";s.r(a);var _=s(3),v=Object(_.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p",[t._v("索引是数据库中用来提高性能的常用工具，简单的介绍 MySQL5.7 支持的索引类型及其设计原则")]),t._v(" "),a("ul",[a("li",[t._v("覆盖索引")]),t._v(" "),a("li",[t._v("联合索引（最左匹配原则）")]),t._v(" "),a("li",[t._v("索引列不参与计算")]),t._v(" "),a("li",[t._v("子查询优化多分页")]),t._v(" "),a("li",[t._v("explain 查看执行计划")]),t._v(" "),a("li",[t._v("事务内尽量简洁高效")])]),t._v(" "),a("h2",{attrs:{id:"概述"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#概述"}},[t._v("#")]),t._v(" 概述")]),t._v(" "),a("p",[t._v("所有的 MySQL 列都可以被设为索引，对相关列使用索引是提高 SELECT 性能的最佳途径。根据存储引擎可以定义每个表最大的索引数和最大索引长度，每种存储引擎对每张表支持"),a("strong",[t._v("最少 16 个索引")]),t._v("，"),a("strong",[t._v("总索引长度至少为 265 个字节")]),t._v("；大多数存储引擎有更高的限制。\nMyISAM 和 InnoDB 存储引擎的表默认创建的都是 BTREE (B 树) 索引，MEMORY 存储引擎使用 HASH 索引，但也支持 BTREE 索引。")]),t._v(" "),a("h3",{attrs:{id:"btree-索引"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#btree-索引"}},[t._v("#")]),t._v(" BTREE 索引")]),t._v(" "),a("h4",{attrs:{id:"特点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#特点"}},[t._v("#")]),t._v(" 特点")]),t._v(" "),a("ul",[a("li",[t._v("以 B+树结构存储数据，大大加快了数据的查询速度")]),t._v(" "),a("li",[t._v("在范围查找的 SQL 语句中更加适合（顺序存储）")])]),t._v(" "),a("h4",{attrs:{id:"场景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#场景"}},[t._v("#")]),t._v(" 场景")]),t._v(" "),a("ul",[a("li",[t._v("全值匹配的查询 SQL")]),t._v(" "),a("li",[t._v("联合索引汇中匹配到最左前缀查询")]),t._v(" "),a("li",[t._v("匹配模糊查询的前匹配")]),t._v(" "),a("li",[t._v("匹配范围值的 SQL 查询（"),a("code",[t._v("not in")]),t._v("和"),a("code",[t._v("<>")]),t._v("无法使用索引）")]),t._v(" "),a("li",[t._v("覆盖索引的 SQL 查询")])]),t._v(" "),a("h3",{attrs:{id:"hash-索引"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#hash-索引"}},[t._v("#")]),t._v(" HASH 索引")]),t._v(" "),a("h4",{attrs:{id:"特点-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#特点-2"}},[t._v("#")]),t._v(" 特点")]),t._v(" "),a("ul",[a("li",[t._v("基于 Hash 表实现，只有查询条件精确匹配 Hash 索引中的所有列才会用到")]),t._v(" "),a("li",[t._v("为 Hash 索引中的每一列都计算 hash 码并存储，所以每次读取都会进行两次查询")]),t._v(" "),a("li",[t._v("Hash 索引无法用于排序")]),t._v(" "),a("li",[t._v("Hash 不适用于区分度小的列上，如性别字段")])]),t._v(" "),a("h3",{attrs:{id:"小结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#小结"}},[t._v("#")]),t._v(" 小结")]),t._v(" "),a("p",[t._v("当对索引字段进行范围查询时，只有 BTREE 索引可以通过索引访问，而 HASH 索引则会进行全表扫描；如果一定要使用范围查询，那么创建索引时就应该选择 BTREE 索引。")]),t._v(" "),a("h2",{attrs:{id:"使用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用"}},[t._v("#")]),t._v(" 使用")]),t._v(" "),a("h3",{attrs:{id:"创建索引"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#创建索引"}},[t._v("#")]),t._v(" 创建索引")]),t._v(" "),a("p",[t._v("索引在创建表的时候可以同时创建，也可以随时增加新的索引")]),t._v(" "),a("div",{staticClass:"language-bash line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[t._v("CREATE "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("UNIQUE"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v("FULLTEXT"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v("SPATIAL"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" INDEX index_name\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("index_type"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n    ON tbl_name "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("index_col_name,"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("..")]),t._v("."),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("index_option"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("algorithm_option "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" lock_option"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("..")]),t._v(".\n    \n    index_col_name:\n        col_name "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("length"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("ASC "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" DESC"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("    \n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br"),a("span",{staticClass:"line-number"},[t._v("8")]),a("br")])]),a("p",[t._v("也可以是使用 ALTER TABLE 的语法来增加索引，语法与 CREATE INDEX 类似")]),t._v(" "),a("h3",{attrs:{id:"删除索引"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#删除索引"}},[t._v("#")]),t._v(" 删除索引")]),t._v(" "),a("div",{staticClass:"language-bash line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[t._v("DROP INDEX index_name ON tbl_name\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("h2",{attrs:{id:"原则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#原则"}},[t._v("#")]),t._v(" 原则")]),t._v(" "),a("ol",[a("li",[t._v("选择唯一性索引")])]),t._v(" "),a("p",[t._v("唯一性索引的值是唯一的，可以更快速的通过该索引来确定某条记录。")]),t._v(" "),a("blockquote",[a("p",[t._v("例如“学生表中学号是具有唯一性的字段。为该字段建立唯一性索引可以很快的确定某个学生的信息。\n如果使用姓名的话，可能存在同名现象，从而降低查询速度。")])]),t._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[t._v("为经常需要排序、分组和联合操作的字段建立索引")])]),t._v(" "),a("p",[t._v("经常需要 ORDER BY、GROUP BY、DISTINCT 和 UNION 等操作的字段，排序操作会浪费很多时间；为其建立索引，可以有效地避免排序操作。")]),t._v(" "),a("ol",{attrs:{start:"3"}},[a("li",[t._v("要在条件列上创建索引，而不是查询列")])]),t._v(" "),a("p",[t._v("最适合索引的列是出现在 WHERE 语法中的列，或连接子句中指定的列，而不是出现在 SELECT 关键词后的列；如果某个字段经常用来做查询条件，那么该字段的查询速度会影响整个表的查询速度；为这样的字段建立索引，可以提高整个表的查询速度。")]),t._v(" "),a("ol",{attrs:{start:"4"}},[a("li",[t._v("限制索引的数目")])]),t._v(" "),a("p",[t._v("索引的数目并不是越多越好，每个索引都需要占用磁盘空间，索引越多，需要的磁盘空间就越大。修改表时，对索引的重构和更新很麻烦；越多的索引，会使更新表变得很浪费时间。")]),t._v(" "),a("ol",{attrs:{start:"5"}},[a("li",[t._v("尽量使用数据量少的索引")])]),t._v(" "),a("p",[t._v("如果索引的值很长，那么查询的速度会受到影响。")]),t._v(" "),a("blockquote",[a("p",[t._v("例如：对一个 CHAR（100）类型的字段进行全文检索需要的时间肯定要比对 CHAR（10）类型的字段需要的时间要多。")])]),t._v(" "),a("ol",{attrs:{start:"6"}},[a("li",[t._v("尽量使用前缀来索引")])]),t._v(" "),a("p",[t._v("如果索引字段的值很长，最好使用值的前缀来索引。")]),t._v(" "),a("blockquote",[a("p",[t._v("例如：TEXT 和 BLOG 类型的字段，进行全文检索会很浪费时间；如果只检索字段的前面的若干个字符，这样可以提高检索速度。")])]),t._v(" "),a("ol",{attrs:{start:"7"}},[a("li",[t._v("删除不再使用或者很少使用的索引")])]),t._v(" "),a("p",[t._v("表中的数据被大量更新，或者数据的使用方式被改变后，原有的一些索引可能不再需要。数据库管理员应当定期找出这些索引，将它们删除，从而减少索引对更新操作的影响。")]),t._v(" "),a("ol",{attrs:{start:"8"}},[a("li",[t._v("小表不应建立索引")])]),t._v(" "),a("p",[t._v("包含大量的列并且不需要搜索非空值的时候可以考虑不建索引")])])}),[],!1,null,null,null);a.default=v.exports}}]);