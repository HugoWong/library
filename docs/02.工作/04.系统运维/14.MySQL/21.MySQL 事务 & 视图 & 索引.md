---
title: MySQL 事务 & 视图 & 索引
date: 2023-01-09 00:05:00
permalink: /pages/c9fdc6/
author: 
  name: JunYu
  link: https://yuwei.cc
article: false
---
## 事务
MySQL 事务主要用于处理操作量大，复杂度高的数据
### 说明

- 在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务
- 事务处理可以用来维护数据库的完整性，保证成批的 SQL 语句要么全部执行，要么全部不执行。
- 事务用来管理 INSERT、UPDATE、DELETE 语句
### 条件
#### 原子性
Atomicity：每个事务（Transaction）都看作最小逻辑操作，不可进行分割；执行错误，会被回滚（Rollback）到事务开始前
#### 一致性
Consistency：在事务开始之前和事务结束以后，数据库的完整性没有被破坏
#### 隔离性
Isolation：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。

- 读未提交（Read Uncommitted）：允许脏读取，但不允许更新丢失；通过“排他写锁”实现
- 读提交（Read Committed）：不可重复读取，但不允许脏读取；通过“瞬间共享读锁”和“排他写锁”实现
- 可重复读（Repeatable Read）：禁止不可重复读取和脏读取，但是有时可能出现幻读数据；通过“共享读锁”和“排他写锁”实现
- 序列化（Serializable）：提供严格的事务隔离。它要求事务序列化执行，事务只能一个接着一个地执行，不能并发执行
#### 持久性
Durability：当事务执行完毕（事务提交），该操作将永久的改变了数据库中的数据
### 语句
```basic
BEGIN 或 START TRANSACTION 显式地开启一个事务；
COMMIT 也可以使用 COMMIT WORK，不过二者是等价的。COMMIT 会提交事务，并使已对数据库进行的所有修改成为永久性的；
ROLLBACK 也可以使用 ROLLBACK WORK，不过二者是等价的。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改；
SAVEPOINT identifier，SAVEPOINT 允许在事务中创建一个保存点，一个事务中可以有多个 SAVEPOINT；
RELEASE SAVEPOINT identifier 删除一个事务的保存点，当没有指定的保存点时，执行该语句会抛出一个异常；
ROLLBACK TO identifier 把事务回滚到标记点；
SET TRANSACTION 用来设置事务的隔离级别。InnoDB 存储引擎提供事务的隔离级别有READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ 和 SERIALIZABLE。
```
### 方法
#### 手动提交
用 BEGIN、ROLLBACK、COMMIT 来实现
```basic
#开始一个事务
BEGIN
#事务回滚
ROLLBACK
#事务确认
COMMIT
```
#### 自动提交
直接用 SET 来改变 MySQL 的自动提交模式
```basic
禁止自动提交
SET AUTOCOMMIT=0
开启自动提交
SET AUTOCOMMIT=1
```
## 视图
> 表中存放的是实际的数据，而视图中存放的是 SQL 查询语句

当我们使用视图时，会运行视图里的 SQL 查询语句创建出一张临时表，当客户端与数据库之间的连接断开后，临时表会被自动删除
### 优势
#### 简单
使用视图的用户完全不需要关心后面对应的表的结构、关联条件、和筛选条件
#### 安全
使用视图的用户只能访问他们被允许查询的结果集，对表的权限管理并不能限制到某个行某个列，而通过视图可以轻松实现
#### 独立
一旦视图的结构确定了，可以屏蔽表结构变化对用户的影响，源表增加列对视图没有影响；源表修改列名，可通过修改视图来解决，不会对访问者造成影响
### 操作
视图的操作跟 MySQL 一样，包括增、删、改、查
#### 创建
创建视图需要有 CREATE VIEW 的权限，并且对于查询涉及到的列有 SELECT 权限；如果使用 CREATE OR REPLACE，那么哈需要有该视图的 DROP 权限
```sql
CREATE [OR REPLACE] [ALGORITHM = {UNDEFINED|MERGE|TEMPTABLE}] VIEW view_name [(column_list)] AS select_statement [WITH [CASCADED | LOCAL] CHECK OPTION] 
```
#### 修改
```sql
ALTER [ALGORITHM={UNDEFINED|MERGE|TEMPTABLE}] VIEW view_name [(column_list)] AS select_statement [WITH [CASCADED|LOCAL] CHEDK OPTION];
```
#### 删除
```sql
DROP VIEW [IF EXISTS] view_name [,view_name...] [RESTRICT|CASCADE];
```
#### 查看
MySQL v5.1 开始，使用`SHOW TABLES`命令显示表名的同时也会显示视图的名字，不存在单独显示视图的`SHOW VIEW`命令
## 索引
索引是数据库中用来提高性能的常用工具，简单的介绍 MySQL5.7 支持的索引类型及其设计原则

- 覆盖索引
- 联合索引（最左匹配原则）
- 索引列不参与计算
- 子查询优化多分页
- explain 查看执行计划
- 事务内尽量简洁高效
### 概述
所有的 MySQL 列都可以被设为索引，对相关列使用索引是提高 SELECT 性能的最佳途径。根据存储引擎可以定义每个表最大的索引数和最大索引长度，每种存储引擎对每张表支持**最少 16 个索引**，**总索引长度至少为 265 个字节**；大多数存储引擎有更高的限制。
MyISAM 和 InnoDB 存储引擎的表默认创建的都是 BTREE (B 树) 索引，MEMORY 存储引擎使用 HASH 索引，但也支持 BTREE 索引。
### BTREE 索引
#### 特点

- 以 B+树结构存储数据，大大加快了数据的查询速度
- 在范围查找的 SQL 语句中更加适合（顺序存储）
#### 场景
- 全值匹配的查询 SQL
- 联合索引汇中匹配到最左前缀查询
- 匹配模糊查询的前匹配
- 匹配范围值的 SQL 查询（`not in`和`<>`无法使用索引）
- 覆盖索引的 SQL 查询
### HASH 索引
#### 特点
- 基于 Hash 表实现，只有查询条件精确匹配 Hash 索引中的所有列才会用到
- 为 Hash 索引中的每一列都计算 hash 码并存储，所以每次读取都会进行两次查询
- Hash 索引无法用于排序
- Hash 不适用于区分度小的列上，如性别字段
### 小结
当对索引字段进行范围查询时，只有 BTREE 索引可以通过索引访问，而 HASH 索引则会进行全表扫描；如果一定要使用范围查询，那么创建索引时就应该选择 BTREE 索引。
### 使用
### 创建索引
索引在创建表的时候可以同时创建，也可以随时增加新的索引
```bash
CREATE [UNIQUE|FULLTEXT|SPATIAL] INDEX index_name
    [index_type]
    ON tbl_name (index_col_name,...)
    [index_option]
    [algorithm_option | lock_option]...
    
    index_col_name:
        col_name [(length)] [ASC | DESC]    
```
也可以是使用 ALTER TABLE 的语法来增加索引，语法与 CREATE INDEX 类似
### 删除索引
```bash
DROP INDEX index_name ON tbl_name
```
### 原则

- 选择唯一性索引

唯一性索引的值是唯一的，可以更快速的通过该索引来确定某条记录。
> 例如“学生表中学号是具有唯一性的字段。为该字段建立唯一性索引可以很快的确定某个学生的信息。
> 如果使用姓名的话，可能存在同名现象，从而降低查询速度。

- 为经常需要排序、分组和联合操作的字段建立索引

经常需要 ORDER BY、GROUP BY、DISTINCT 和 UNION 等操作的字段，排序操作会浪费很多时间；为其建立索引，可以有效地避免排序操作。

- 要在条件列上创建索引，而不是查询列

最适合索引的列是出现在 WHERE 语法中的列，或连接子句中指定的列，而不是出现在 SELECT 关键词后的列；如果某个字段经常用来做查询条件，那么该字段的查询速度会影响整个表的查询速度；为这样的字段建立索引，可以提高整个表的查询速度。

- 限制索引的数目

索引的数目并不是越多越好，每个索引都需要占用磁盘空间，索引越多，需要的磁盘空间就越大。修改表时，对索引的重构和更新很麻烦；越多的索引，会使更新表变得很浪费时间。

- 尽量使用数据量少的索引

如果索引的值很长，那么查询的速度会受到影响。
> 例如：对一个 CHAR（100）类型的字段进行全文检索需要的时间肯定要比对 CHAR（10）类型的字段需要的时间要多。

- 尽量使用前缀来索引

如果索引字段的值很长，最好使用值的前缀来索引。
> 例如：TEXT 和 BLOG 类型的字段，进行全文检索会很浪费时间；如果只检索字段的前面的若干个字符，这样可以提高检索速度。

- 删除不再使用或者很少使用的索引

表中的数据被大量更新，或者数据的使用方式被改变后，原有的一些索引可能不再需要。数据库管理员应当定期找出这些索引，将它们删除，从而减少索引对更新操作的影响。

- 小表不应建立索引

包含大量的列并且不需要搜索非空值的时候可以考虑不建索引